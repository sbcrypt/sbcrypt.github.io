## Lesson 2.2.2: The Unbreakable Dream - The One-Time Pad (OTP)

Imagine using a keystream that is:

*   Generated by a TRNG (truly random).
*   As long as your message.
*   Known *only* to the sender and receiver.
*   **NEVER, EVER REUSED.**

This is the **One-Time Pad (OTP)**. It's **unconditionally secure**. That means even with infinite computing power, it *cannot* be broken. Why? Because for every ciphertext bit `y`, the original plaintext `x` could equally likely be 0 or 1, since the keystream bit `s` was truly random. No information is leaked!

**Sounds perfect! Why don't we use it for everything?**
It's incredibly impractical:

*   Need a massive, truly random key (as long as the message).
*   Securely sharing that huge key beforehand is a nightmare.
*   Using the same key stream twice (a "two-time pad") is CATASTROPHIC. (See puzzle below!)

ðŸ“œ **Crypto Trivia:** The "Red Telephone" hotline between Washington D.C. and Moscow during the Cold War is rumored to have used One-Time Pads delivered by trusted couriers for ultimate security.

***

**ðŸ¤¯ Brain Teaser: The Danger of Reusing a Keystream!**

Oscar the Eavesdropper intercepts two ciphertexts, `y1` and `y2`, encrypted with the *same* OTP keystream `s`. He doesn't know the plaintext `x1` or `x2`, nor the keystream `s`.

*   `y1 = x1 âŠ• s`
*   `y2 = x2 âŠ• s`

What happens if Oscar XORs the two ciphertexts together? `y1 âŠ• y2 = ?` What valuable information does he get, even without knowing the key?

<button onclick="revealAnswer('otpAnswer', this)">Reveal Answer</button>
<span id="otpAnswer" style="display: none;">
*(Answer: `y1 âŠ• y2 = x1 âŠ• x2`. Oscar gets the XOR sum of the two plaintexts! This leaks a *huge* amount of information. If Oscar knows or can guess one of the plaintexts (e.g., `x1`), he can immediately find the other (`x2 = (x1 âŠ• x2) âŠ• x1`). This is why reusing a keystream is disastrous.)*
</span>

***

---

[Previous: Lesson 2.2 - Randomness & RNGs](ch02_randomness.html) | [Next: Lesson 2.2.3 - Practical Stream Ciphers](ch02_practical.html)

<script>
function revealAnswer(answerId, buttonElement) {
  const answerElement = document.getElementById(answerId);
  if (answerElement) {
    answerElement.style.display = 'inline'; // Or 'block' if needed
  }
  if (buttonElement) {
    buttonElement.style.display = 'none'; // Hide button after clicking
  }
}
</script> 