## Explaining the LFSR Linearity Attack

The fatal flaw of using a simple LFSR for keystream generation is its **linearity**. This means the relationship between the LFSR's state bits and its output can be described using linear equations (specifically, addition modulo 2, which is XOR).

Let's see how Oscar can exploit this with our 3-bit LFSR example.

**Scenario:**

*   **The LFSR:** A 3-bit LFSR (`m=3`).
*   **The Unknown:** Oscar knows it's a 3-bit LFSR, but he *doesn't* know the feedback rule. The general rule is `s_{i+3} = p_2 s_{i+2} ⊕ p_1 s_{i+1} ⊕ p_0 s_i`. The `p_0, p_1, p_2` are the secret feedback coefficients (0 or 1) Oscar wants to find. (In our specific example from the animation, we know `p_2=0`, `p_1=1`, `p_0=1`, but Oscar starts without this knowledge).
*   **Known Information (Known Plaintext Attack):** Oscar has intercepted some ciphertext `y` and somehow knows the corresponding plaintext `x` for a short period. By XORing them (`s_i = x_i ⊕ y_i`), he obtains `2m = 2*3 = 6` consecutive bits of the **keystream**. Let's say the keystream sequence starts `s_0, s_1, s_2, s_3, s_4, s_5 = 0, 0, 1, 0, 1, 1` (this is the sequence generated by our example LFSR starting at `100`).

**Oscar's Goal:** Find the feedback coefficients `p_0, p_1, p_2`.

**Setting up the Equations:**

Oscar uses the general LFSR rule and the known keystream bits to create equations. He needs `m=3` equations to solve for the `m=3` unknowns (`p_0, p_1, p_2`).

1.  `s_3 = p_2 s_2 ⊕ p_1 s_1 ⊕ p_0 s_0`
2.  `s_4 = p_2 s_3 ⊕ p_1 s_2 ⊕ p_0 s_1`
3.  `s_5 = p_2 s_4 ⊕ p_1 s_3 ⊕ p_0 s_2`

**Substituting Known Keystream Values:**

Now Oscar plugs in the known values of `s_i`:

1.  `0 = p_2(1) ⊕ p_1(0) ⊕ p_0(0)`
2.  `1 = p_2(0) ⊕ p_1(1) ⊕ p_0(0)`
3.  `1 = p_2(1) ⊕ p_1(0) ⊕ p_0(1)`

**Simplifying the Equations:**

Remember that `X ⊕ 0 = X` and `X ⊕ X = 0`. Also `p_i(k)` is just `p_i` if `k=1` and `0` if `k=0`.

1.  `0 = p_2`
2.  `1 = p_1`
3.  `1 = p_2 ⊕ p_0`

**Solving the System:**

This system is very easy to solve!

*   From (1), Oscar immediately knows `p_2 = 0`.
*   From (2), Oscar immediately knows `p_1 = 1`.
*   Substitute `p_2 = 0` into (3): `1 = 0 ⊕ p_0`, which means `p_0 = 1`.

**Result:**

Oscar has successfully recovered the secret feedback coefficients: `p_2=0`, `p_1=1`, `p_0=1`. He now knows the exact feedback rule for this LFSR: `s_{i+3} = s_{i+1} ⊕ s_i`.

**Why is this Bad?**

Knowing the feedback rule means Oscar can predict the *entire* future keystream sequence if he knows just `m=3` consecutive bits of the state at any point. Since he already derived 6 bits of the keystream, he knows the initial state (`s_2, s_1, s_0 = 100` - although he might need a bit more keystream to uniquely determine the starting state in some cases) and can generate all subsequent keystream bits `s_6, s_7, ...`. This completely breaks the cipher.

**Key Takeaway:** Because the relationship is linear, only a small amount of known keystream (`2m` bits) is needed to set up and solve linear equations to find the LFSR's secret structure. This is computationally very easy.

---

<div class="page-navigation">
    <a href="ch02_lfsr.html" class="prev">← Previous: LFSRs Overview</a>
    <a href="ch02_nonlinear.html" class="next">Next: Non-Linearity & Trivium →</a>
</div>

<script src="../scripts/main.js"></script>